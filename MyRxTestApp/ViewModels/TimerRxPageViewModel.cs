using System;
using System.Diagnostics;
using System.Reactive;
using System.Reactive.Concurrency;
using System.Reactive.Linq;
using System.Windows.Input;
using Xamarin.Forms;

namespace MyRxTestApp.ViewModels
{
    public class TimerRxPageViewModel : BaseViewModel
    {
        private bool _isTimerStarted = false;
        private IDisposable _disposable;

        private string _msg;
        public string Msg
        {
            get { return _msg; }
            set
            {
                if (_msg != value)
                {
                    _msg = value;
                    OnPropertyChanged("Msg");
                }
            }
        }

        public ICommand StartTimerCommand { get; set; }
        public ICommand StartTimerOnceCommand { get; set; }
        public ICommand StartTimerWithDelayCommand { get; set; }
        public ICommand StartTimerUIThreadCommand { get; set; }


        public TimerRxPageViewModel()
        {
            StartTimerCommand = new Command(StartTimerClick);
            StartTimerOnceCommand = new Command(StartTimerOnceClick);
            StartTimerWithDelayCommand = new Command(StartTimerWithDelayClicked);
            StartTimerUIThreadCommand = new Command(StartTimerUIThreadClicked);

        }

        private void StartTimerClick()
        {
            if (!_isTimerStarted)
            {
                _isTimerStarted = true;
                _disposable = Observable.Interval(TimeSpan.FromSeconds(2))
                .Subscribe(x =>
                {
                    Msg = "Called : " + x + "\n";
                    Debug.WriteLine("StartTimerClick: " + x);

                });
                
            }
            else
            {
                _isTimerStarted = false;

                _disposable.Dispose();

            }

        }

        private void StartTimerOnceClick()
        {
            Observable.Timer(TimeSpan.FromSeconds(3))
                .Subscribe(x =>
                {
                    Msg = "Called Once : " + x + "\n";

                });

        }

        private void StartTimerWithDelayClicked()
        {
            Observable.Timer(TimeSpan.FromMinutes(1), TimeSpan.FromSeconds(3))
                .Subscribe(x =>
                {
                    Msg = "Called after delay : " + x + "\n";

                });
        }

        private void StartTimerUIThreadClicked()
        {
            //Creates an Observable that emits sequential numbers every specified interval of time, on a specified IScheduler.
            Observable.Interval(TimeSpan.FromSeconds(2), Scheduler.ThreadPool)
                .Subscribe(x =>
                {
                    Msg = "Called UI Thread : " + x + "\n";

                });
            //By using the ThreadPool scheduler, the sequence of integers will be generated by a    ***//
            //*** thread in the .NET thread so the main thread is not blocked.
        }

        private void StartTimerWithDelayUIThreadClicked()
        {
            //Creates an Observable that starts emitting after an initialDelay and emits ever increasing numbers after each period of time thereafter.
            Observable.Timer(TimeSpan.FromMinutes(1), TimeSpan.FromSeconds(3), Scheduler.ThreadPool)
                .Subscribe(x =>
                {
                    Msg = "Called after delay : " + x + "\n";

                });
        }
    }
}
